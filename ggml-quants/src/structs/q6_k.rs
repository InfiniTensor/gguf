use super::_256;
use crate::{DataBlock, Quantize};
use half::f16;

/// Q6K 量化结构体
#[repr(C)]
pub struct Q6K {
    /// 低位量化值
    pub ql: [u8; _256 / 2],
    /// 高位量化值
    pub qh: [u8; _256 / 4],
    /// 局部缩放因子
    pub scales: [u8; _256 / 16],
    /// 全局缩放因子
    pub delta: f16,
}

impl_data_block! {
    Q6K = crate::types::Q6K;
    Self {
        ql: [0; _256 / 2],
        qh: [0; _256 / 4],
        scales: [0; _256 / 16],
        delta: f16::ZERO,
    }
}

impl Q6K {
    fn make_qx_quants(x: &[f32; 16]) -> f32 {
        let nmax = 32;
        let mut max = 0.0f32;
        let mut amax = 0.0f32;
        for &val in x {
            let ax = val.abs();
            if ax > amax {
                amax = ax;
                max = val;
            }
        }

        if amax < 1e-15 {
            return 0.0;
        }

        let iscale = -(nmax as f32) / max;

        let mut sumlx = 0.0;
        let mut suml2 = 0.0;

        for &val in x {
            let l = (iscale * val).round();
            let l_clamped = l.clamp(-(nmax as f32), (nmax - 1) as f32);
            let w = val * val;
            sumlx += w * val * l_clamped;
            suml2 += w * l_clamped * l_clamped;
        }

        let mut scale = if suml2 > 0.0 { sumlx / suml2 } else { 0.0 };
        let mut best = scale * sumlx;

        for is_i in -9..=9 {
            if is_i == 0 {
                continue;
            }
            let is = is_i as f32;

            let current_iscale = -(nmax as f32 + 0.1 * is) / max;
            sumlx = 0.0;
            suml2 = 0.0;
            for &val in x {
                let l = (current_iscale * val).round();
                let l_clamped = l.clamp(-(nmax as f32), (nmax - 1) as f32);
                let w = val * val;
                sumlx += w * val * l_clamped;
                suml2 += w * l_clamped * l_clamped;
            }

            if suml2 > 0.0 && sumlx * sumlx > best * suml2 {
                scale = sumlx / suml2;
                best = scale * sumlx;
            }
        }

        scale
    }
}

impl Quantize<f32, _256> for Q6K {
    fn quantize(data: &[f32; _256]) -> Self {
        let mut scales = [0.0f32; 16];
        for i in 0..16 {
            let mut block = [0.0f32; 16];
            block.copy_from_slice(&data[i * 16..(i + 1) * 16]);
            scales[i] = Self::make_qx_quants(&block);
        }

        let mut max_scale = 0.0;
        let mut max_abs_scale = 0.0;
        for &s in &scales {
            let s_abs = s.abs();
            if s_abs > max_abs_scale {
                max_abs_scale = s_abs;
                max_scale = s;
            }
        }

        if max_abs_scale < 1e-15 {
            return Self::ZEROS;
        }

        let iscale = -128.0 / max_scale;
        let d = 1.0 / iscale;

        let mut sc = [0u8; 16];
        let mut sc_i8 = [0i8; 16];
        for i in 0..16 {
            let quantized_s = (scales[i] * iscale).round().clamp(-128.0, 127.0) as i8;
            sc_i8[i] = quantized_s;
        }
        let transmuted = unsafe { std::mem::transmute::<[i8; 16], [u8; 16]>(sc_i8) };
        sc.copy_from_slice(&transmuted);

        let mut ql = [0u8; 128];
        let mut qh = [0u8; 64];

        for n in (0.._256).step_by(128) {
            let sc_offset = n / 16;
            for l in 0..32 {
                let is = l / 16;

                let d_0 = d * sc_i8[sc_offset + is] as f32;
                let d_1 = d * sc_i8[sc_offset + is + 2] as f32;
                let d_2 = d * sc_i8[sc_offset + is + 4] as f32;
                let d_3 = d * sc_i8[sc_offset + is + 6] as f32;

                let v0 = data[n + l];
                let v1 = data[n + l + 32];
                let v2 = data[n + l + 64];
                let v3 = data[n + l + 96];

                let q0 = if d_0 == 0.0 {
                    0
                } else {
                    (v0 / d_0).round().clamp(-32.0, 31.0) as i8
                };
                let q1 = if d_1 == 0.0 {
                    0
                } else {
                    (v1 / d_1).round().clamp(-32.0, 31.0) as i8
                };
                let q2 = if d_2 == 0.0 {
                    0
                } else {
                    (v2 / d_2).round().clamp(-32.0, 31.0) as i8
                };
                let q3 = if d_3 == 0.0 {
                    0
                } else {
                    (v3 / d_3).round().clamp(-32.0, 31.0) as i8
                };

                let uq0 = (q0 + 32) as u8;
                let uq1 = (q1 + 32) as u8;
                let uq2 = (q2 + 32) as u8;
                let uq3 = (q3 + 32) as u8;

                let ql_low_i = n / 2 + l;
                let ql_high_i = ql_low_i + 32;
                let qh_i = n / 4 + l;

                ql[ql_low_i] = (uq0 & 0x0F) | ((uq2 & 0x0F) << 4);
                ql[ql_high_i] = (uq1 & 0x0F) | ((uq3 & 0x0F) << 4);

                qh[qh_i] = ((uq0 >> 4) & 0x03)
                    | (((uq1 >> 4) & 0x03) << 2)
                    | (((uq2 >> 4) & 0x03) << 4)
                    | (((uq3 >> 4) & 0x03) << 6);
            }
        }

        Self {
            delta: f16::from_f32(d),
            scales: sc,
            ql,
            qh,
        }
    }

    fn dequantize(&self) -> [f32; _256] {
        let d = self.delta.to_f32();
        let mut y = [0.0f32; 256];
        let sc: &[i8; 16] = unsafe { &*(self.scales.as_ptr() as *const [i8; 16]) };

        for n in (0.._256).step_by(128) {
            let ql_offset = n / 2;
            let qh_offset = n / 4;
            let sc_offset = n / 16;
            for l in 0..32 {
                let is = l / 16;
                let q1 = ((self.ql[ql_offset + l] & 0x0F) | ((self.qh[qh_offset + l] & 0x03) << 4))
                    as i8
                    - 32;
                let q2 = ((self.ql[ql_offset + l + 32] & 0x0F)
                    | ((self.qh[qh_offset + l] & 0x0C) << 2)) as i8
                    - 32;
                let q3 =
                    ((self.ql[ql_offset + l] >> 4) | (self.qh[qh_offset + l] & 0x30)) as i8 - 32;
                let q4 = ((self.ql[ql_offset + l + 32] >> 4)
                    | ((self.qh[qh_offset + l] & 0xC0) >> 2)) as i8
                    - 32;

                y[n + l] = d * sc[sc_offset + is] as f32 * q1 as f32;
                y[n + l + 32] = d * sc[sc_offset + is + 2] as f32 * q2 as f32;
                y[n + l + 64] = d * sc[sc_offset + is + 4] as f32 * q3 as f32;
                y[n + l + 96] = d * sc[sc_offset + is + 6] as f32 * q4 as f32;
            }
        }
        y
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const F32_DATA: [f32; 256] = [
        0.014892578,
        0.0008544922,
        0.011474609,
        0.003692627,
        0.010009766,
        0.0038604736,
        -0.0069885254,
        -0.0010681152,
        -0.0053100586,
        -0.0019836426,
        -0.0068969727,
        0.0043640137,
        0.002105713,
        0.0008010864,
        0.017333984,
        -0.007019043,
        2.1457672e-5,
        -0.005432129,
        0.001739502,
        0.00024318695,
        -0.0018539429,
        0.006591797,
        -0.0014419556,
        -0.006164551,
        0.00023937225,
        0.0095825195,
        0.0048828125,
        -0.0015182495,
        -0.008850098,
        -0.0027008057,
        0.0064086914,
        0.0011138916,
        0.0008506775,
        -0.004180908,
        -0.0039978027,
        0.0014038086,
        -0.017700195,
        -0.0058898926,
        0.0087890625,
        -0.01977539,
        -0.0058898926,
        -0.0021514893,
        -0.0041503906,
        0.0069274902,
        0.021606445,
        -0.002746582,
        -0.0021362305,
        0.0033721924,
        -0.012207031,
        0.0017242432,
        -0.0027008057,
        0.0049743652,
        0.005004883,
        -0.016479492,
        0.0032348633,
        -0.0095825195,
        -0.002090454,
        -0.0024719238,
        -0.024414063,
        -0.004425049,
        0.00092697144,
        0.00061035156,
        0.0008506775,
        0.0039978027,
        0.00020599365,
        -0.002243042,
        -0.0095825195,
        0.0095825195,
        0.006011963,
        0.011413574,
        0.008178711,
        -0.004180908,
        0.004333496,
        -0.0026245117,
        0.0024108887,
        0.00491333,
        0.0046691895,
        0.0054016113,
        -0.0007095337,
        0.0057373047,
        0.0039367676,
        0.0078125,
        0.009460449,
        0.0014877319,
        -0.0011520386,
        0.021362305,
        0.004547119,
        0.011962891,
        0.0024108887,
        -0.0029296875,
        0.0035552979,
        -0.0069885254,
        -0.012268066,
        0.010375977,
        0.0043945313,
        -0.0078125,
        -0.014343262,
        0.0070495605,
        0.00025558472,
        0.00010347366,
        -0.00390625,
        -0.0030059814,
        -0.0068359375,
        -0.0033721924,
        -0.0054016113,
        -0.00038909912,
        -0.0014801025,
        -0.0047302246,
        -0.0049743652,
        -0.0066223145,
        0.00089645386,
        -0.0071105957,
        -0.0004234314,
        0.009033203,
        0.005126953,
        0.009155273,
        0.0011978149,
        0.011047363,
        0.0047912598,
        -0.005706787,
        0.0034179688,
        -0.01159668,
        -0.000121593475,
        0.0018081665,
        -0.004058838,
        0.00029563904,
        -0.00793457,
        0.004760742,
        -0.0021514893,
        -0.0043640137,
        -0.0029754639,
        0.014770508,
        0.011291504,
        -0.004760742,
        -0.009338379,
        0.007232666,
        0.000541687,
        -0.005859375,
        0.011962891,
        0.008911133,
        0.0115356445,
        0.0030059814,
        0.016235352,
        -0.0038146973,
        0.0068969727,
        0.01574707,
        -0.0073547363,
        0.016723633,
        0.013305664,
        -0.005340576,
        0.0119018555,
        0.013671875,
        -0.005432129,
        0.008544922,
        0.010131836,
        -0.0012207031,
        -0.00021076202,
        0.00970459,
        0.005493164,
        0.0071105957,
        -0.0045166016,
        0.0015792847,
        -0.006225586,
        -3.7670135e-5,
        -0.011047363,
        -0.0021209717,
        0.0049743652,
        -0.012023926,
        0.0015182495,
        0.00038719177,
        -0.0045776367,
        0.0011291504,
        0.008117676,
        0.008911133,
        -0.0048828125,
        -0.006134033,
        0.0065612793,
        0.015380859,
        -0.0044555664,
        0.0046691895,
        0.0065612793,
        0.0040283203,
        0.009277344,
        0.0058898926,
        0.0095825195,
        -0.0025024414,
        -0.002166748,
        0.018066406,
        0.013549805,
        0.0019073486,
        0.004760742,
        0.0068359375,
        0.0154418945,
        0.0014419556,
        -0.003540039,
        -0.010803223,
        0.012939453,
        -0.008239746,
        -0.0013504028,
        0.0048217773,
        -0.008483887,
        0.0030670166,
        -0.009521484,
        0.0010375977,
        -0.0115356445,
        0.013671875,
        0.0048217773,
        -0.013061523,
        -0.007598877,
        -0.017089844,
        -0.024169922,
        -0.0027923584,
        -0.00059890747,
        0.00088882446,
        7.915497e-5,
        0.01977539,
        -0.004486084,
        0.0015258789,
        -0.0036773682,
        -0.0018997192,
        -0.0020141602,
        -0.0087890625,
        -0.0005264282,
        0.00970459,
        -0.0047912598,
        0.007598877,
        0.0033874512,
        -0.001411438,
        0.0138549805,
        0.0021209717,
        0.008544922,
        -0.0011367798,
        -0.014404297,
        0.002746582,
        -0.001159668,
        -0.0003490448,
        -0.00093078613,
        0.0064086914,
        -0.011291504,
        0.0033111572,
        0.006225586,
        -0.0039367676,
        0.013549805,
        -0.0049438477,
        -0.009521484,
        0.0036468506,
        0.004547119,
        0.0065307617,
        -0.0018539429,
        0.006500244,
        0.004058838,
        -0.0040283203,
        0.003753662,
        -0.002532959,
        0.0022888184,
        0.0068359375,
    ];
    const Q6_K_BLOCK: [u8; 210] = [
        245, 110, 187, 89, 254, 9, 157, 194, 74, 116, 157, 40, 60, 31, 32, 13, 160, 82, 42, 239,
        38, 27, 149, 244, 207, 65, 176, 165, 45, 25, 171, 188, 15, 6, 22, 14, 122, 153, 19, 141,
        73, 243, 214, 86, 80, 20, 35, 11, 240, 146, 237, 150, 54, 235, 212, 4, 157, 13, 1, 90, 81,
        17, 161, 213, 4, 216, 118, 100, 90, 25, 50, 98, 31, 171, 73, 239, 138, 74, 97, 183, 99,
        147, 14, 193, 247, 26, 10, 167, 170, 32, 189, 210, 208, 78, 246, 211, 84, 20, 128, 208,
        243, 91, 61, 209, 4, 97, 212, 243, 229, 231, 115, 112, 36, 149, 24, 184, 100, 137, 96, 22,
        79, 20, 116, 144, 120, 109, 184, 4, 20, 233, 184, 133, 76, 73, 70, 110, 90, 106, 90, 85,
        81, 89, 168, 86, 86, 219, 149, 217, 170, 192, 154, 71, 149, 36, 145, 166, 123, 154, 24,
        169, 70, 218, 166, 120, 192, 182, 235, 81, 57, 154, 116, 88, 124, 141, 20, 182, 85, 128,
        10, 148, 212, 102, 100, 116, 146, 105, 88, 146, 82, 148, 85, 101, 89, 50, 110, 128, 58,
        112, 183, 197, 85, 88, 193, 92, 79, 133, 183, 71, 103, 128,
    ];

    #[test]
    fn test_const_data_dequantize() {
        let const_q = {
            let ql = Q6_K_BLOCK[0..128].try_into().unwrap();
            let qh = Q6_K_BLOCK[128..192].try_into().unwrap();
            let scales = Q6_K_BLOCK[192..208].try_into().unwrap();
            let delta = f16::from_le_bytes(Q6_K_BLOCK[208..210].try_into().unwrap());
            Q6K {
                ql,
                qh,
                scales,
                delta,
            }
        };
        let dq = const_q.dequantize();
        for (i, (a, b)) in dq.iter().zip(F32_DATA.iter()).enumerate() {
            assert!((a - b).abs() < 1e-3, "mismatch at {}: {} vs {}", i, a, b);
        }
    }

    #[test]
    fn test_const_data_quantize() {
        let const_q = {
            let ql = Q6_K_BLOCK[0..128].try_into().unwrap();
            let qh = Q6_K_BLOCK[128..192].try_into().unwrap();
            let scales = Q6_K_BLOCK[192..208].try_into().unwrap();
            let delta = f16::from_le_bytes(Q6_K_BLOCK[208..210].try_into().unwrap());
            Q6K {
                ql,
                qh,
                scales,
                delta,
            }
        };
        let q = Q6K::quantize(&F32_DATA);

        assert!(
            (q.delta.to_f32() - const_q.delta.to_f32()).abs() < 1e-5,
            "delta mismatch, {} vs {}",
            q.delta.to_f32(),
            const_q.delta.to_f32()
        );
        assert_eq!(q.scales, const_q.scales, "scales mismatch");
        assert_eq!(q.ql, const_q.ql, "ql mismatch");
        assert_eq!(q.qh, const_q.qh, "qh mismatch");
    }
}
